// queueMicrotask()

// Брат setTimeout, или как добавить синхронную функцию в очередь микрозадач



// Кратко

// Браузерное API, которое выполняет переданный код асинхронно


// Как пишется


// queueMicrotask():

// 1. Принимает функцию, которая будет передана в очередь микрозадач;
// 2. Возвращает undefined.



queueMicrotask(() => {
    console.log('Хэй, я выполнюсь асинхронно!')
})




// Как понять

// Код выше схож со сценарием использования setTimeout(). 
// Оба выполнят код асинхронно:


setTimeout(() => {
    console.log('Хэй я выполняюсь асинхронно благодоря setTimeout') 
})



/* Так в чем же принципиальная разница между ними? 

    queueMicrotask() добавляет переданную функцию в очередь микрозадач. 
    Функции в этой очереди выполняются одна за другой (FIFO: First in First 
    Out) — когда текущая функция выполнилась, запускается следующая 
    функция в очереди.

    Все микрозадачи в очереди будут выполнены только после того, как текущий 
    стек вызовов окажется пустым, но перед выполнением следующей макрозадачей.

    Если вернуться к сравнению с setTimeout(), то передаваемые в него функции 
    этого относятся к макрозадачам. Каждая из них будет взята из очереди 
    задач, после того как управление передастся циклу событий.

    Поэтому, если вызвать queueMicrotask() после setTimeout(), или наоборот — 
    функция, переданная в queueMicrotask(), начнёт своё исполнение первой.

*/ 



/* JavaScript имеет в своём арсенале различные виды очередей, 

    а также стек вызовов. Давайте кратко разберём необходимый минимум, 
    который поможет разобраться с процессом работы:


    Стек вызовов — служит для выполнения синхронных операций;
    Очередь микрозадач — контейнер для хранения асинхронных операций, 
    имеющих высокий приоритет;
    Очередь макрозадач — контейнер для хранения асинхронных операций с 
    низким приоритетом.
    Что же, кажется, самое время рассмотреть процесс работы между этими 
    самыми элементами:

    Первый, кто начинает процесс выполнения — стек вызовов;
    После того, как JavaScript убеждается, в том, что стек пуст — в него по 
    очереди добавляются задачи из очереди микрозадач;
    Процесс выполнения продолжается до тех пор, пока не станет ясно, что 
    очередь опустела. Как только это произойдёт — выполняются задачи из 
    очередь макрозадач;
    Очередь макрозадач является завершающим этапом. После того как список 
    в нем станет пустым — все повторяется по новой.

*/ 









/* Пример

    Убедимся, что функция, переданная в queueMicrotask() выполнится раньше, 
    чем через setTimeout(). Для этого создадим страницу с формой, при 
    отправке которой будут запускаться оба задания. Каждое из них будет 
    печатать на экран уникальный текст:

*/ 

// При отправке формы запустим наши задачи — первым будет располагаться 
// setTimeout(), а после него queueMicrotask().
const handleFormSubmit = (e) => {
    e.preventDefault()

    setTimeout(() => {
      output.innerText += 'Фраза добавлена из setTimeout()\n\n'
    }, 0)
    queueMicrotask(() => {
      output.innerText += 'Фраза добавлена из queueMicrotask()\n'
    })
}




/* Подсказки

    Основная причина использования queueMicrotask() — обеспечение 
    последовательности выполнения задач, одновременно снижая риск заметных 
    пользователю задержек в операциях.



    Представим ситуацию, в которой необходимо получать данные по указанному 
    урлу. Либо же, если запрос выполнялся ранее — запросить данные из кэша:

*/ 




